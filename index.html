<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<title>Crazy Ragdoll Playground Mobile</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
body { margin:0; overflow:hidden; background:#222; touch-action:none; }
canvas{ display:block; }
#ui{
  position:absolute; top:10px; left:10px; color:white; font-family:sans-serif; z-index:10;
  display:flex; flex-wrap:wrap;
}
button{
  margin:5px; padding:10px 15px; font-size:16px; border:none; border-radius:6px; background:#444; color:white;
}
button:active{ background:#666; }
</style>
</head>
<body>

<div id="ui">
<button id="slowmoBtn">SlowMo</button>
<button id="breakBtn">Break Joint</button>
<button id="saveBtn">Save</button>
<button id="loadBtn">Load</button>
<button id="spawnBallBtn">Spawn Ball</button>
<button id="explosionBtn">Explosion</button>
<button id="gunBtn">Gun: ON</button>
<button id="autoGunBtn">AutoGun: OFF</button>
<button id="shotgunBtn">Shotgun: OFF</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.165.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>

<script>
let scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);

let camera = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,7,15);

let renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

let controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0,3,0);
controls.enableDamping = true;

scene.add(new THREE.DirectionalLight(0xffffff,1.2).position.set(10,15,10));
scene.add(new THREE.AmbientLight(0x555555));

let world = new CANNON.World();
world.gravity.set(0,-9.82,0);

let ragdoll=[], joints=[], slowmo=false;
let gunEnabled=true, autoGun=false, shotgun=false;
let raycaster = new THREE.Raycaster(), touch=new THREE.Vector2();
let selectedBody=null;

// --- Podlaha a stěny ---
let groundBody = new CANNON.Body({ mass:0, shape:new CANNON.Plane() });
groundBody.quaternion.setFromEuler(-Math.PI/2,0,0);
world.addBody(groundBody);

scene.add(new THREE.Mesh(new THREE.PlaneGeometry(50,50), new THREE.MeshStandardMaterial({color:0x444444})));
scene.children[scene.children.length-1].rotation.x=-Math.PI/2;

function addWall(x,z,w,h,d){
  let body = new CANNON.Body({ mass:0, shape:new CANNON.Box(new CANNON.Vec3(w/2,h/2,d/2))});
  body.position.set(x,h/2,z); world.addBody(body);
  let mesh = new THREE.Mesh(new THREE.BoxGeometry(w,h,d), new THREE.MeshStandardMaterial({color:0x888888}));
  mesh.position.copy(body.position); scene.add(mesh);
}
addWall(0,-25,50,5,1);
addWall(-25,0,1,5,50);
addWall(25,0,1,5,50);

// --- Ragdoll ---
function createRagdoll(x=0,y=5,z=0){
  let parts=[]; let material = new CANNON.Material();

  let torso = new CANNON.Body({mass:5, shape:new CANNON.Box(new CANNON.Vec3(0.5,1,0.25)), material});
  torso.position.set(x,y,z); world.addBody(torso); parts.push(torso);
  torso.mesh = new THREE.Mesh(new THREE.BoxGeometry(1,2,0.5), new THREE.MeshStandardMaterial({color:0xff4444})); scene.add(torso.mesh);

  let head = new CANNON.Body({mass:1, shape:new CANNON.Sphere(0.35), material});
  head.position.set(x,y+1.5,z); world.addBody(head); parts.push(head);
  head.mesh = new THREE.Mesh(new THREE.SphereGeometry(0.35,32,32), new THREE.MeshStandardMaterial({color:0xffff44})); scene.add(head.mesh);
  joints.push(new CANNON.LockConstraint(torso,head));

  let armShape = new CANNON.Box(new CANNON.Vec3(0.2,0.7,0.2));
  let leftArm = new CANNON.Body({mass:1, shape:armShape, material}); leftArm.position.set(x-0.7,y,z); world.addBody(leftArm); parts.push(leftArm);
  leftArm.mesh = new THREE.Mesh(new THREE.BoxGeometry(0.4,1.4,0.4), new THREE.MeshStandardMaterial({color:0x44ff44})); scene.add(leftArm.mesh);
  joints.push(new CANNON.LockConstraint(torso,leftArm));

  let rightArm = new CANNON.Body({mass:1, shape:armShape, material}); rightArm.position.set(x+0.7,y,z); world.addBody(rightArm); parts.push(rightArm);
  rightArm.mesh = new THREE.Mesh(new THREE.BoxGeometry(0.4,1.4,0.4), new THREE.MeshStandardMaterial({color:0x44ff44})); scene.add(rightArm.mesh);
  joints.push(new CANNON.LockConstraint(torso,rightArm));

  let legShape = new CANNON.Box(new CANNON.Vec3(0.25,0.8,0.25));
  let leftLeg = new CANNON.Body({mass:2, shape:legShape, material}); leftLeg.position.set(x-0.3,y-1.5,z); world.addBody(leftLeg); parts.push(leftLeg);
  leftLeg.mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5,1.6,0.5), new THREE.MeshStandardMaterial({color:0x4444ff})); scene.add(leftLeg.mesh);
  joints.push(new CANNON.LockConstraint(torso,leftLeg));

  let rightLeg = new CANNON.Body({mass:2, shape:legShape, material}); rightLeg.position.set(x+0.3,y-1.5,z); world.addBody(rightLeg); parts.push(rightLeg);
  rightLeg.mesh = new THREE.Mesh(new THREE.BoxGeometry(0.5,1.6,0.5), new THREE.MeshStandardMaterial({color:0x4444ff})); scene.add(rightLeg.mesh);
  joints.push(new CANNON.LockConstraint(torso,rightLeg));

  ragdoll.push(...parts);
}
createRagdoll();

// --- Touch drag ---
function getTouchPos(t){
  let rect = renderer.domElement.getBoundingClientRect();
  return {
    x: (t.clientX-rect.left)/rect.width*2-1,
    y: -(t.clientY-rect.top)/rect.height*2+1
  };
}

renderer.domElement.addEventListener('touchstart', e=>{
  let t = e.touches[0];
  let pos = getTouchPos(t);
  touch.x=pos.x; touch.y=pos.y;
  raycaster.setFromCamera(touch,camera);
  const intersects = ragdoll.filter(b=>b.mesh).map(b=>b.mesh);
  const hit = raycaster.intersectObjects(intersects)[0];
  if(hit) selectedBody=ragdoll.find(b=>b.mesh===hit.object);

  // střelba pokud ne nad tlačítkem
  let targetTag = e.target.tagName;
  if(gunEnabled && targetTag!=="BUTTON" && !selectedBody){
    let dir = new THREE.Vector3(); camera.getWorldDirection(dir);
    shootBullet(camera.position, dir);
  }
});
renderer.domElement.addEventListener('touchmove', e=>{
  if(selectedBody){
    let t = e.touches[0];
    let pos = getTouchPos(t);
    touch.x=pos.x; touch.y=pos.y;
    raycaster.setFromCamera(touch,camera);
    const planeZ = new THREE.Plane(new THREE.Vector3(0,0,1),0);
    const pos3 = new THREE.Vector3();
    raycaster.ray.intersectPlane(planeZ,pos3);
    selectedBody.position.set(pos3.x,pos3.y,pos3.z);
    selectedBody.velocity.set(0,0,0);
  }
});
renderer.domElement.addEventListener('touchend', e=>{ selectedBody=null; });

// --- UI events ---
document.getElementById('slowmoBtn').onclick=()=>slowmo=!slowmo;
document.getElementById('breakBtn').onclick=()=>{ if(joints.length>0) world.removeConstraint(joints.pop()); };
document.getElementById('saveBtn').onclick=()=>{
  const data = ragdoll.map(b=>({x:b.position.x,y:b.position.y,z:b.position.z})); localStorage.setItem('ragdollSave',JSON.stringify(data)); alert('Saved!');
};
document.getElementById('loadBtn').onclick=()=>{
  const data = JSON.parse(localStorage.getItem('ragdollSave')||'[]'); 
  if(data.length!==ragdoll.length) return alert('Saved data mismatch'); 
  data.forEach((pos,i)=>{ ragdoll[i].position.set(pos.x,pos.y,pos.z); ragdoll[i].velocity.set(0,0,0); });
};
document.getElementById('spawnBallBtn').onclick=()=>{
  let ball = new CANNON.Body({mass:2, shape:new CANNON.Sphere(0.3)});
  let dir=new THREE.Vector3(); camera.getWorldDirection(dir);
  ball.position.copy(camera.position).add(dir.clone().multiplyScalar(2));
  ball.velocity.copy(dir.multiplyScalar(15));
  world.addBody(ball);
  let mesh = new THREE.Mesh(new THREE.SphereGeometry(0.3,16,16), new THREE.MeshStandardMaterial({color:0xff00ff}));
  ball.mesh=mesh; scene.add(mesh);
  ball.addEventListener('collide',e=>{ if(e.body.mesh) e.body.mesh.material.color.setHex(Math.random()*0xffffff); });
};
document.getElementById('explosionBtn').onclick=()=>{
  let center = new CANNON.Vec3(0,5,0);
  ragdoll.forEach(b=>{ b.applyImpulse(b.position.vsub(center).scale(10), b.position); });
};
document.getElementById('gunBtn').onclick=()=>{ gunEnabled=!gunEnabled; document.getElementById('gunBtn').innerText = gunEnabled ? "Gun: ON":"Gun: OFF"; };
document.getElementById('autoGunBtn').onclick=()=>{ autoGun=!autoGun; document.getElementById('autoGunBtn').innerText = autoGun ? "AutoGun: ON":"AutoGun: OFF"; };
document.getElementById('shotgunBtn').onclick=()=>{ shotgun=!shotgun; document.getElementById('shotgunBtn').innerText = shotgun ? "Shotgun: ON":"Shotgun: OFF"; };

// --- Shoot function ---
function shootBullet(pos, dir, speed=35){
  if(shotgun){
    let angles=[-0.2,0,-0.2,0.2,0.1];
    angles.forEach(a=>{
      let d=dir.clone(); d.x+=a; d.y+=a;
      createBullet(pos,d,speed);
    });
  }else createBullet(pos,dir,speed);
}

function createBullet(pos,dir,speed){
  let bullet = new CANNON.Body({mass:0.3, shape:new CANNON.Sphere(0.08), position: new CANNON.Vec3(pos.x,pos.y,pos.z)});
  bullet.velocity.copy(new CANNON.Vec3(dir.x*speed, dir.y*speed, dir.z*speed));
  world.addBody(bullet);
  let mesh = new THREE.Mesh(new THREE.SphereGeometry(0.08,8,8), new THREE.MeshStandardMaterial({color:0xffff00}));
  bullet.mesh=mesh; scene.add(mesh);
  bullet.addEventListener('collide', (e)=>{
    if(e.body && e.body.mesh){
      e.body.mesh.material.color.setHex(0xff0000);
      if(joints.length>0 && Math.random()<0.3) world.removeConstraint(joints.pop());
    }
    world.removeBody(bullet); scene.remove(mesh);
  });
}

// --- Animation loop ---
let clock = new THREE.Clock();
function animate(){
  requestAnimationFrame(animate);
  let dt = clock.getDelta()*(slowmo?0.1:1);
  world.step(1/60, dt, 3);

  ragdoll.forEach(b=>{ if(b.mesh){ b.mesh.position.copy(b.position); b.mesh.quaternion.copy(b.quaternion); } });
  world.bodies.forEach(b=>{ if(b.mesh){ b.mesh.position.copy(b.position); b.mesh.quaternion.copy(b.quaternion); } });

  if(autoGun && gunEnabled){
    let dir = new THREE.Vector3(); camera.getWorldDirection(dir);
    shootBullet(camera.position, dir);
  }

  controls.update();
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{ camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth,window.innerHeight); });

</script>
</body>
</html>
